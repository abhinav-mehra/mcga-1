#! /usr/bin/env stap

# This section contains code to probe non-inline functions
# such functions have a probing point when they are called
# and when they return.

global redis_server
probe begin {
    redis_server = $1
    printf("Start...\n")
    printf("Redis Binary: ")
    printf("%s\n", redis_server)
}

function trace(entry_p)
{
  printf("%s%s%s\n",
         thread_indent (entry_p),
         (entry_p>0?"->":"<-"),
         ppfunc ())
}

probe kernel.function("handle_mm_fault").call,
      kernel.function("sys_mmap").call,
      kernel.function("do_huge_pmd_anonymous_page").call,
      kernel.function("do_huge_pmd_wp_page").call,
      kernel.function("copy_user_huge_page").call,
      kernel.function("clear_huge_page").call {
    if (pid() == target()) {
        trace(1)
    }
}

probe kernel.function("handle_mm_fault").return,
      kernel.function("sys_mmap").return,
      kernel.function("do_huge_pmd_anonymous_page").return,
      kernel.function("do_huge_pmd_wp_page").return,
      kernel.function("copy_user_huge_page").return,
      kernel.function("clear_huge_page").return {
    if (pid() == target()) {
        trace(-1)
    }
}

probe kernel.function("__alloc_pages_nodemask").call {
    if ((pid() == target())) {
        entry_p = 1
  	    printf("%s%s%s args %s\n",
               thread_indent (entry_p),
               (entry_p>0?"->":"<-"),
               ppfunc (), $$parms)
    }
}

probe kernel.function("__alloc_pages_nodemask").return {
    if ((pid() == target())) {
        trace(-1)
	if ($order == 9) {
	}
    }
}

global final_addr

probe kernel.function("do_mmap_pgoff").call {
    if ((pid() == target())) {
        entry_p = 1
  	    printf("%s%s%s address 0x%x len %u\n",
               thread_indent (entry_p),
               (entry_p>0?"->":"<-"),
               ppfunc (), $addr, $len)
		final_addr = $addr
    }
}

probe kernel.function("do_mmap_pgoff").return {
    if ((pid() == target())) {
        entry_p = -1
  	    printf("%s%s%s address 0x%x len %u\n",
               thread_indent (entry_p),
               (entry_p>0?"->":"<-"),
               ppfunc (), final_addr, $len)
    }
}

probe kernel.statement("do_mmap_pgoff@mm/mmap.c:1305") {
    if ((pid() == target())) {
	final_addr = $addr
    }
}

#probe kernel.function("alloc_pages_current").call {
      #kernel.function("new_slab").call,
      #kernel.function("slab_alloc_node").inline {
#    if (pid() == target()) {
#	print_backtrace()
#    }
#}

#probe kernel.function("alloc_pages_current").return,
#      kernel.function("new_slab").return {
#    if (pid() == target()) {
#        trace(-1)
#    }
#}
#global proc_count=0
probe process($1).function("arena_chunk_alloc").call,
      process($1).function("createClient").call,
      process($1).function("setCommand").call {
	trace(1)
}

probe process($1).function("arena_chunk_alloc").return,
      process($1).function("createClient").return,
      process($1).function("setCommand").return {
	trace(-1)
}
#probe end {
#	printf("count is %lu\n", proc_count)
#}
